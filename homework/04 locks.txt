-- посмотрим, что кластер стартовал
pg_lsclusters

sudo -u postgres psql

SELECT * FROM pg_locks \gx
SELECT pg_backend_pid();

SELECT pg_blocking_pids(5490);
SHOW log_lock_waits;


CREATE DATABASE locks;
\c locks
-- увидим, что pid изменился
SELECT pg_backend_pid();

-- посмотрим, что например VIEW тоже является видом RELATION
CREATE TABLE t (i serial);

BEGIN;
SELECT * FROM pg_locks;
CREATE VIEW v AS SELECT * FROM t;
SELECT * FROM pg_locks;
SELECT relname FROM pg_class WHERE oid = 24945;
ROLLBACK;


-- рекомендательные блокировки advisory_lock
-- https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS
-- https://habr.com/ru/company/tensor/blog/488024/
-- во втором терминале
begin; 
SELECT hashtext('lock me pls');
SELECT pg_advisory_lock(hashtext('lock me pls'));
SELECT pg_backend_pid();
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 1261;

--попробуем в первом терминале
SELECT pg_advisory_lock(hashtext('lock me pls'));
SELECT * FROM pg_locks;
-- advisory для каждой БД


-- во втором терминале
-- что произойдет? почему, как думаете?
commit; 







-- commit не освобождает блокировку
SELECT pg_advisory_unlock(hashtext('lock me pls'));
-- освободить можно только под своим PID


-- посмотрим различные виды блокировок и как найти, кто нас блокирует. 
-- Для это мы будет работать из 2 параллельных терминаловв и, соответственно, сессий
CREATE TABLE accounts(id integer, amount numeric);
INSERT INTO accounts VALUES (1,200.00), (2,300.00), (3,400.00);

-- во втором окне
BEGIN;
SELECT pg_backend_pid();
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 1261;
UPDATE accounts SET amount = amount + 1 WHERE id = 1;

-- смотрим опять блокировки - что изменилось и почему?
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks WHERE pid = 5789;


-- зайдем в первом терминале
SELECT pg_backend_pid();
CREATE INDEX ON accounts(id);
-- Что произойдет?
-- проверим во втором терминале
SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, mode, granted FROM pg_locks;

-- узнаем, кто нас блокирует
-- таймаут лока
-- https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-LOCK-TIMEOUT
SELECT pg_blocking_pids(1294); 

-- и что вообще происходит PG_STAT_ACTIVITY
SELECT * FROM pg_stat_activity WHERE pid = ANY(pg_blocking_pids(1294)) \gx
commit;
-- в 1 окне видим как создался индекс


-- более глубокое исследование блокировки строк
-- объяснения про побитовую маску
-- https://habr.com/ru/company/postgrespro/blog/445820/
CREATE EXTENSION pageinspect;
DROP VIEW IF EXISTS accounts_v;
CREATE VIEW accounts_v AS
SELECT '(0,'||lp||')' AS ctid,
       t_xmin as xmin,
       t_xmax as xmax,
       CASE WHEN (t_infomask & 1024) > 0  THEN 't' END AS commited,
       CASE WHEN (t_infomask & 2048) > 0  THEN 't' END AS aborted,
       CASE WHEN (t_infomask & 128) > 0   THEN 't' END AS lock_only,
       CASE WHEN (t_infomask & 4096) > 0  THEN 't' END AS is_multi,
       CASE WHEN (t_infomask2 & 8192) > 0 THEN 't' END AS keys_upd
FROM heap_page_items(get_raw_page('accounts',0))
WHERE lp <= 10
ORDER BY lp;


SELECT * FROM accounts_v ;
TRUNCATE accounts;
INSERT INTO accounts VALUES (1,2000.00), (2,2000.00), (3,2000.00);
SELECT * FROM accounts_v ;

BEGIN;
UPDATE accounts SET id = 4 WHERE id = 1;
UPDATE accounts SET amount = 4000 WHERE id = 3;
SELECT * FROM accounts_v ;
-- что изменилось?

-- во втором терминале
BEGIN;
SELECT * FROM accounts WHERE id = 2 FOR KEY SHARE;
SELECT * FROM accounts WHERE id = 3 FOR KEY SHARE;
SELECT * FROM accounts_v;
CREATE EXTENSION pgrowlocks;
SELECT * FROM pgrowlocks('accounts') \gx

-- Очередь ожидания
CREATE VIEW locks_v AS
SELECT pid,
       locktype,
       CASE locktype
         WHEN 'relation' THEN relation::REGCLASS::text
         WHEN 'virtualxid' THEN virtualxid::text
         WHEN 'transactionid' THEN transactionid::text
         WHEN 'tuple' THEN relation::REGCLASS::text||':'||tuple::text
       END AS lockid,
       mode,
       granted
FROM pg_locks;


SELECT * FROM locks_v;

-- заблокируем строку в разделяемом режиме
BEGIN;
SELECT txid_current(), pg_backend_pid();
SELECT * FROM accounts WHERE id = 3 FOR SHARE;

-- второй терминал
BEGIN;
SELECT txid_current(), pg_backend_pid();
UPDATE accounts set amount = 4000 WHERE id = 3;
-- в первом терминале
SELECT * FROM locks_v WHERE pid = 1294;
SELECT pg_blocking_pids(1294);

-- третий терминал
sudo -u postgres psql
\c locks

BEGIN;
SELECT * FROM accounts WHERE id = 3 FOR SHARE;
SELECT * FROM pgrowlocks('accounts') \gx

-- обычно получаем блокировку, а в этом режиме получим ошибку
SELECT * FROM accounts FOR UPDATE NOWAIT; 
-- третий терминал
ROLLBACK;
BEGIN;

-- для многопоточной обработки данных
-- DECLARE c CURSOR FOR SELECT * FROM accounts ORDER BY id FOR UPDATE SKIP LOCKED;
-- FETCH C; 



